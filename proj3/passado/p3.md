Based on the `p3.pdf` source provided, here are the requirements, testing strategies, and potential pitfalls for the third project.

### **Project Requirements**

**Goal:**
You must develop a module for an application that analyzes football championships. Specifically, for a given team, you must calculate the **minimum number of games** that team needs to win to still have a mathematical chance of winning the championship.

**Rules & Logic:**
*   **Format:** The championship consists of two symmetric rounds where every team plays every other team twice (home and visitor).
*   **Points:** 3 points for a win, 1 point for a draw, 0 points for a loss.
*   **Objective:** You need to determine if a specific team can win given the current standings (based on games already played) and assuming favorable results in the remaining games (including tie-breakers).

**Implementation Constraints:**
*   **Method:** You must model the problem using **Linear Programming**.
*   **Language:** The implementation must be done in **Python**.
*   **Library:** You must use the **PuLP** library to solve the LP problems,.
*   **Execution:** The program should be executed via the command line: `python3 vossoprograma.py < ficheiro_de_input`.

**Input Format:**
*   Line 1: Two integers, $n$ (number of teams) and $m$ (games already played).
*   Next $m$ lines: Results of played games in the format: `home_team_ID away_team_ID winner_ID` (where `winner_ID` is 0 in case of a draw).

**Output Format:**
*   You must print $n$ lines.
*   Line $i$ corresponds to team $i$ and should contain a single integer: the minimum number of wins required for that team to win the championship.
*   If it is impossible for team $i$ to win, output **-1**.

---

### **How and What to Test**

To get the best scores, you should focus on the following testing procedures:

**1. Setup the Environment:**
Ensure you have the necessary tools installed. Unlike previous projects, this requires Python and a specific solver:
*   Install PuLP: `python -m pip install pulp`.
*   Install a solver like **GLPK** (recommended) or LP_solve. For example, on Ubuntu: `sudo apt-get install glpk-utils`.

**2. Verify Against Provided Examples:**
The project description provides three specific input/output examples. You should create local test files for these and ensure your output matches exactly.

*   **Input 1 (3 teams, 1 game played):** Team 1 beat Team 2.
    *   Expected Output: `1`, `0`, `1`.
*   **Input 2 (3 teams, 4 games played):** Various results provided.
    *   Expected Output: `-1`, `0`, `0`. (Note the -1 indicating Team 1 cannot win).
*   **Input 3 (3 teams, 3 games played):** Includes a draw.
    *   Expected Output: `2`, `0`, `0`.

**3. Use the `diff` Command:**
The evaluation system uses the `diff` command to compare your output against the expected result. Your program passes a test only if `diff` produces no output (meaning identical files).
*   Command: `diff output result`.

**4. Test Logic with Constraints:**
You need to test if your Linear Programming model correctly handles:
*   **Remaining Games:** Calculate how many games are left between every pair of teams based on the input $n$ and the list of played games.
*   **Points Calculation:** Ensure wins (3pts) and draws (1pt) are correctly summed.
*   **Optimization Goal:** The objective function of your LP should minimize the target team's wins while ensuring their total points $\ge$ every other team's total points.

---

### **What to Watch Out For**

**1. Language Change:**
Unlike the first two projects where C++ was preferred, this project **requires** Python. Do not submit C++ code.

**2. Solver Dependencies:**
Simply installing the Python library `PuLP` might not be enough if the underlying solver (like GLPK) is missing from the system. Ensure your local environment matches the requirements to avoid runtime errors.

**3. Outputting -1:**
A critical edge case is determining when a team has *zero* chance of winning regardless of future outcomes. Ensure your model can detect infeasibility or that you have a pre-check logic to output `-1` in these cases.

**4. Performance Limits:**
While Python is slower than C++, the time limit is generous (15 hours estimated for implementation, though standard execution time limits on Mooshak still apply). However, verify that your LP model is not creating an excessive number of variables or constraints that would cause a timeout on larger inputs.

**5. Anti-Cheating Mechanisms:**
The evaluation system looks for solutions adjusted to specific inputs or those that output random/constant values. Hardcoding answers for the example inputs will likely result in penalties. Only the last submission is considered for evaluation.