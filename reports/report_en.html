<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ASA Project Report</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">ASA Project Report</h1>
</header>
<h1 id="asa-20252026-project-1-report">ASA 2025/2026 Project 1
Report</h1>
<p><strong>Group:</strong> AL114 <strong>Student(s):</strong> 111179 and
110600</p>
<hr />
<h2 id="problem-and-solution-description">Problem and Solution
Description</h2>
<p>The problem involves calculating the number of distinct paths between
pairs of intersections in a directed acyclic graph (DAG) and assigning
truck routes based on this count. The proposed solution uses an
iterative approach based on topological sorting to ensure nodes are
processed in the correct dependency order, avoiding recursion and stack
overflow issues.</p>
<p>To optimize cache and memory usage, we implemented a <strong>Batched
Dynamic Programming</strong> scheme. We process source nodes in blocks
(e.g., 128), maintaining path counters only for the current batch. Path
propagation follows the linearized topological order (Kahn’s algorithm),
where for each node, we sum paths from its predecessors and propagate
them to its successors, updating counters modulo <span
class="math inline"><em>M</em></span>.</p>
<h2 id="theoretical-analysis">Theoretical Analysis</h2>
<p>The algorithm is divided into the following main steps:</p>
<ol type="1">
<li><p><strong>Graph Reading and In-Degree Calculation</strong>:
Iterating over the <span class="math inline"><em>K</em></span> edges to
build the adjacency list and degree vector. <strong>Complexity:</strong>
<span
class="math inline"><em>O</em>(<em>N</em> + <em>K</em>)</span></p></li>
<li><p><strong>Topological Sort (Kahn’s Algorithm)</strong>: Inserting
nodes with degree 0 into a queue and iteratively removing them, visiting
each edge once. <strong>Complexity:</strong> <span
class="math inline"><em>O</em>(<em>N</em> + <em>K</em>)</span></p></li>
<li><p><strong>Batch Processing (Core Solution)</strong>: For each block
of sources, we traverse the graph in topological order. In the worst
case (dense graph), we process all edges for each batch. With <span
class="math inline"><em>B</em></span> being the batch size, we have
<span class="math inline"><em>N</em>/<em>B</em></span> outer iterations.
<strong>Complexity:</strong> <span class="math inline">$O(\frac{N}{B}
\times (N + K))$</span></p></li>
</ol>
<p><strong>Global Complexity:</strong> Since <span
class="math inline"><em>B</em></span> is a constant, the complexity
simplifies to: <span
class="math display"><em>O</em>(<em>N</em> × (<em>N</em> + <em>K</em>))</span></p>
<p>In the worst case (dense graph where <span
class="math inline"><em>K</em> ≈ <em>N</em><sup>2</sup></span>), it is
<span class="math inline"><em>O</em>(<em>N</em><sup>3</sup>)</span>. For
sparse graphs, it approaches <span
class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span>.</p>
<h2 id="experimental-evaluation">Experimental Evaluation</h2>
<p>Experiments were conducted on a machine with an Apple M-series CPU,
using randomly generated instances with constant density. The goal was
to verify the correlation between execution time and the predicted
theoretical complexity <span
class="math inline"><em>O</em>(<em>N</em> × (<em>N</em> + <em>K</em>))</span>.</p>
<h3 id="results-table">Results Table</h3>
<p>More than 10 instances of incremental size were generated.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">N (Vertices)</th>
<th style="text-align: left;">K (Edges)</th>
<th style="text-align: left;">Time (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">200</td>
<td style="text-align: left;">5937</td>
<td style="text-align: left;">0.0172</td>
</tr>
<tr>
<td style="text-align: left;">300</td>
<td style="text-align: left;">13620</td>
<td style="text-align: left;">0.0326</td>
</tr>
<tr>
<td style="text-align: left;">400</td>
<td style="text-align: left;">24075</td>
<td style="text-align: left;">0.0595</td>
</tr>
<tr>
<td style="text-align: left;">500</td>
<td style="text-align: left;">37572</td>
<td style="text-align: left;">0.0930</td>
</tr>
<tr>
<td style="text-align: left;">600</td>
<td style="text-align: left;">53856</td>
<td style="text-align: left;">0.1348</td>
</tr>
<tr>
<td style="text-align: left;">800</td>
<td style="text-align: left;">96280</td>
<td style="text-align: left;">0.2466</td>
</tr>
<tr>
<td style="text-align: left;">1000</td>
<td style="text-align: left;">149645</td>
<td style="text-align: left;">0.3608</td>
</tr>
<tr>
<td style="text-align: left;">1200</td>
<td style="text-align: left;">215511</td>
<td style="text-align: left;">0.5350</td>
</tr>
<tr>
<td style="text-align: left;">1400</td>
<td style="text-align: left;">294370</td>
<td style="text-align: left;">0.7506</td>
</tr>
<tr>
<td style="text-align: left;">1600</td>
<td style="text-align: left;">384045</td>
<td style="text-align: left;">0.9868</td>
</tr>
<tr>
<td style="text-align: left;">2000</td>
<td style="text-align: left;">599803</td>
<td style="text-align: left;">1.6834</td>
</tr>
<tr>
<td style="text-align: left;">2200</td>
<td style="text-align: left;">724530</td>
<td style="text-align: left;">1.9516</td>
</tr>
</tbody>
</table>
<h3 id="performance-graph">Performance Graph</h3>
<p>The graph below plots Real Time (Y-axis) against Theoretical
Complexity <span
class="math inline"><em>N</em> × (<em>N</em> + <em>K</em>)</span>
(X-axis).</p>
<figure>
<img src="performance_graph.svg" alt="Time vs Complexity" />
<figcaption aria-hidden="true">Time vs Complexity</figcaption>
</figure>
<p>The linearity observed in the graph confirms that the implementation
follows the theoretical prediction.</p>
</body>
</html>
